# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    README                                             :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: lignigno <lignign@student.21-school.ru>    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2021/06/05 08:18:49 by lignigno          #+#    #+#              #
#    Updated: 2021/06/05 21:29:47 by lignigno         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

В моём случае :
	Программе [client] можно передавать сколько угодно аргументов в том числе
и не передавать.
	Программа [server] читает из нулевого потока "поступающие сигналы" и выводит
полученную строку ввиде символов.

	Когда [client] скажет что отправка закончена [server] выведет на экран
полученную и декодированную информацию.

Как лучше запускать :
	Шаг 1 :
		make
	Шаг 2 :
		./client arg1 arg2 arg3 | ./server

ВОЗМОЖНЫЕ НАСТРОЙКИ в header.h :
	--> FPS                  - отвечают за количество отображений в секунду.
	--> CLIENT_COLOR         - цвет цифр клиента.
	--> SERVER_COLOR         - цвет цифр сервера.
	--> CHANGE               - цвет измняемого символа (push/add).
	--> OFFSET               - цвет зоны смещения.
	--> END_CHARACTER        - символ указывающий на окончание сообщения.
	--> C_direction_sending  - направление чтения СИМВОЛОВ для ОТПРАВКИ.
	--> B_direction_sending  - направление чтения БИТОВ для ОТПРАВКИ.

  \\==========================================================================//
  //==========================================================================\\

ОБЪЯСНЕНИЕ :
	Так как нам нужно отправить строку используя лишь два сигнала то логично
что мы будем передавать биты. Теперь как это делать?

	 /----------------------------------------------\
	| 1) Нам нужно отправить каждый символ строки   |
	|                  следовательно                |
	|   нужно пройтись по каждому СИМВОЛУ в строке. |
	 \----------------------------------------------/

	Как отправить символ используя биты? Ответ очень тупой но верный. Нужно
получать по порядку каждый бит символа.

	 /-------------------------------------------------\
	| 2) Нужно получать по порядку каждый бит символа   |
	|                  следовательно                    |
	|   нужно пройтись по каждому БИТУ в символе.       |
	 \-------------------------------------------------/

	В файле client.c я написал :

/*
	    Написал уточнения и несколько функции чтобы можно было подобрать
	для себя отправку котроя будет более понятна.
	    Направление может меняться в "header.h".
*/

	Что я имел ввиду? Мы можем читать и СИМВОЛЫ (C), и БИТЫ (B) как слева
направо (LR), так и справа налево (RL). В итоге у нас 4 варианта
отправки/получения :

	| C | B |
	---------
	|-->|-->|
	---------
	|-->| < |
	---------
	| < |-->|
	---------
	| < | < |
	---------

	Так же уточню : "Направление должно совпадать по принадлежности". Некоторые
действия могут производиться при чтении символов, а другие при чтении битов.
Действия производимые для чтения символов ПРИНАДЛЕЖАТ РАБОТЕ С СИМВОЛАМИ.
Принадлежность этих действий обозначается как 'C'. Действия производимые для
чтения битов ПРИНАДЛЕЖАТ РАБОТЕ С БИТАМИ. Принадлежность этих действий
обозначается как 'B'. И действия с одной принадлежностью должны выполняться
в одном напрвлении. Если мы устанавливаем итератор (i как его обычноименуют)
так, как если бы мы читали строку LR, то есть i = 0, то и получаем символы слева
направо (ch = str[i]), а не (ch = str[len - i]).

	Теперь перейдём к [client] и [server].

	Сразу скажу что проще работать с двумя действиями, отправка/получение и
смещение.
	Для начала вспомним ft_putnub() в котором мы с конца обрезали каждую цифру
и снова заходили в ft_putnub() до тех пор пока не получим последнюю цифру.

	Как это примерно выглядит :

	в этом направлении мы получали числа, а в этом выводили.
	  <---                                    --->
	12 536 872                             12 536 872

	Получали символы в порядке LR, а выводили наоборот RL. Отсюда получаем
следующий логический вывод.

	 /---------------------------------------------------------\
	|     Если [client] отправляет биты одного символа слева    |
	| направо то [server] должен заполнять биты справа налево.  |
	 \---------------------------------------------------------/

ПРИМЕР :
	К примеру у нас строка состоящая из одного символа в виде '*'.
	Если отправка LR, тогда приём RL и наоборот. Если отправка RL, тогда приём LR.
	В данном случае отправка LR, приём RL.

	что происходит у того и другого в этот момент :

[X]     - Добавленный/отправленный символ.
} или { - Разделение смещения.

step 1	------------[client]---------------------------------[server]------------

		(отправляем сигнал)  |                             |  (смещаем)          
		 | push              |                             |  <<                 
		[0] 0 1 0 1 0 1 0    |                             |  0 0 0 0 0 0 0{0    
		                     |                             |                     
		(смещаем)            |                             |  (получаем сигнал)  
		<<                   |                             |             add |   
		0 1 0 1 0 1 0{0      |                             |  0 0 0 0 0 0 0{[0]  

step 2	------------[client]---------------------------------[server]------------

		(отправляем сигнал)  |                             |  (смещаем)          
		 | push              |                             |  <<                 
		[0] 1 0 1 0 1 0{0    |                             |  0 0 0 0 0 0{0 0    
		                     |                             |                     
		(смещаем)            |                             |  (получаем сигнал)  
		<<                   |                             |             add  |  
		1 0 1 0 1 0{0 0      |                             |  0 0 0 0 0 0{0 [0]  

step 3	------------[client]---------------------------------[server]------------

		(отправляем сигнал)  |                             |  (смещаем)          
		 | push              |                             |  <<                 
		[1] 0 1 0 1 0{0 0    |                             |  0 0 0 0 0{0 0 0    
		                     |                             |                     
		(смещаем)            |                             |  (получаем сигнал)  
		<<                   |                             |             add |  
		0 1 0 1 0{0 0 0      |                             |  0 0 0 0 0{0 0 [1]  

step 4	------------[client]---------------------------------[server]------------

		(отправляем сигнал)  |                             |  (смещаем)          
		 | push              |                             |  <<                 
		[0] 1 0 1 0{0 0 0    |                             |  0 0 0 0{0 0 1 0    
		                     |                             |                     
		(смещаем)            |                             |  (получаем сигнал)  
		<<                   |                             |             add |   
		1 0 1 0{0 0 0 0      |                             |  0 0 0 0{0 0 1 [0]  

step 5	------------[client]---------------------------------[server]------------

		(отправляем сигнал)  |                             |  (смещаем)          
		 | push              |                             |  <<                 
		[1] 0 1 0{0 0 0 0    |                             |  0 0 0{0 0 1 0 0    
		                     |                             |                     
		(смещаем)            |                             |  (получаем сигнал)  
		<<                   |                             |             add |   
		0 1 0{0 0 0 0 0      |                             |  0 0 0{0 0 1 0 [1]  

step 6	------------[client]---------------------------------[server]------------

		(отправляем сигнал)  |                             |  (смещаем)          
		 | push              |                             |  <<                 
		[0] 1 0{0 0 0 0 0    |                             |  0 0{0 0 1 0 1 0    
		                     |                             |                     
		(смещаем)            |                             |  (получаем сигнал)  
		<<                   |                             |             add |   
		1 0{0 0 0 0 0 0      |                             |  0 0{0 0 1 0 1 [0]  

step 7	------------[client]---------------------------------[server]------------

		(отправляем сигнал)  |                             |  (смещаем)          
		 | push              |                             |  <<                 
		[1] 0{0 0 0 0 0 0    |                             |  0{0 0 1 0 1 0 0    
		                     |                             |                     
		(смещаем)            |                             |  (получаем сигнал)  
		<<                   |                             |             add |   
		0{0 0 0 0 0 0 0      |                             |  0{0 0 1 0 1 0 [1]  

step 8	------------[client]---------------------------------[server]------------

		(отправляем сигнал)  |                             |  (смещаем)          
		 | push              |                             |  <<                 
		[0]{0 0 0 0 0 0 0    |                             |  {0 0 1 0 1 0 1 0   
		                     |                             |                     
		(смещаем)            |                             |  (получаем сигнал)  
		<<                   |                             |              add |  
		{0 0 0 0 0 0 0 0     |                             |  {0 0 1 0 1 0 1 [0] 

и т.д.

	Для наглядности можно запустить программу с аргументом ввиде '*' и поставить
FPS 1 или 2.

	По такому же принципу мы добавляем сиволы в строку. Если отправка LR, тогда
добавление RL и наоборот. Если отправка RL, тогда добавление LR.

	Так как это происходит при помощи сигналов то придётся работать с
глобальными переменными, а всё потому что наша функция обработчик может получать
лишь (int signal).

НЕМНОГО ПОЯСНЕНИЙ :
	void (*signal(int, void (*)(int)))(int)

	или как она обычно используется

	signal(SIGNAL, func_name);

	Когда мы прописываем эту функцию в своём коде, то как бы говорим, что
после этой строчки, если в нашу программу попал сигнал SIGNAL, то обраотать
его функцией func_name(int). И когда эта функция будет вызвана то ей
будет передан поступивший сигнал.

	Не трудно догадаться что эта функция будет использована только в [server].
В func_name() мы будем крутиться в цикле пока нам не передадут END_CHARACTER.
В файле server.c в функции main есть подходящий пример такого цикла. Но так
мы получаем только символы для строки, а нам приходят биты, по этому в цикле
вызываем функцию get_char() которая собирает нужное количество битов
для символа.

В итоге у нас набралась следующая структурка :

typedef struct s_global
{
	size_t		len;	// Длина строки
	char		*str;	// Полученная строка
	int			pid;	// Pid отправителя (для бонусов).
}				t_global;

	len необходима так как END_CHARACTER может быть отличен от '\0'.
В таком случае нам придётся писать свою функцию для вывода сиволов.

	Вродебы всё на счёт основного. Также можно заметить size_char это сделано
для Unicode чтобы можно было уточнить размерность символов.

	Самое основное с чего я начал создавать данный ман.
Попробуйте различные комбинаци и подберите для себя более понятную.

	| C | B |
	---------
	|-->|-->|
	---------
	|-->| < |
	---------
	| < |-->|
	---------
	| < | < |
	---------